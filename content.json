[{"title":"play登录状态管理","date":"2018-03-27T02:51:17.000Z","path":"2018/03/27/play-sessions.html","text":"play登录状态管理目录 加密过程 模拟登录 加密过程在play官方文档中有这样的介绍: It’s important to understand that Session and Flash data are not stored by the server but are added to each subsequent HTTP request, using the cookie mechanism. This means that the data size is very limited (up to 4 KB) and that you can only store string values. The default name for the cookie is PLAY_SESSION. This can be changed by configuring the key session.cookieName in application.conf. 大意是说play通过cookie来保存session的信息，只能保存最大为4k的字符串。默认的cookie名字是PLAY_SESSION，可以在application.conf里面配置。 来看一下这个配置是怎么使用，如何通过这个session来保存用户的登录信息。 在application.conf里有如下配置： 1234# Sessionssession.maxAge = 31536000000session.cookieName = my_playapplication.secret=&quot;xxx&quot; application.secret是用来 Signing session cookies and CSRF tokens Built in encryption utilities 在play中一般登录成功后会通过如下方式返回 1Ok(&quot;login success&quot;).withSession(&quot;userId&quot; -&gt; &quot;555&quot;).withCookies(...) 在withSession的调用中会把user_id通过application.secret来加密，并保存到cookie中，然后随结果返回。看一下具体执行的play源码 play.api.mvc.Results.scala中的withSession方法 12345def withSession(session: (String, String)*): Result = withSession(Session(session.toMap))def withSession(session: Session): Result = &#123; if (session.isEmpty) discardingCookies(Session.discard) else withCookies(Session.encodeAsCookie(session)) &#125; play.api.mvc.Http.scala中的encodeAsCookie方法将session转为cookie并签名 123456789101112131415161718192021/** * Encodes the data as a `Cookie`.*/def encodeAsCookie(data: T): Cookie = &#123; val cookie = encode(serialize(data)) Cookie(COOKIE_NAME, cookie, maxAge, path, domain, secure, httpOnly)&#125;/** * Encodes the data as a `String`.*/def encode(data: Map[String, String]): String = &#123; val encoded = data.map &#123; case (k, v) =&gt; URLEncoder.encode(k, &quot;UTF-8&quot;) + &quot;=&quot; + URLEncoder.encode(v, &quot;UTF-8&quot;)&#125;.mkString(&quot;&amp;&quot;) //cookie的value是 加密后的串-userId if (isSigned) Crypto.sign(encoded) + &quot;-&quot; + encoded else encoded&#125; play.api.libs.Crypto.scala使用application.secret对传入的参数进行签名 12345678910def sign(message: String): String = &#123; sign(message, secret.getBytes(&quot;utf-8&quot;))&#125;//最终这个函数返回的就是签名后放在cookie中的userIddef sign(message: String, key: Array[Byte]): String = &#123; val mac = provider.map(p =&gt; Mac.getInstance(&quot;HmacSHA1&quot;, p)).getOrElse(Mac.getInstance(&quot;HmacSHA1&quot;)) mac.init(new SecretKeySpec(key, &quot;HmacSHA1&quot;)) Codecs.toHexString(mac.doFinal(message.getBytes(&quot;utf-8&quot;)))&#125; 模拟登录了解上面原理后可以手动生成cookie，然后模拟登录比如上面例子中，最后服务器验证登录的cookie是my_play-userId = ‘xxx-555’。只要用上面签名的方法，对userId进行签名就可以生成任意用户的登录cookie。生成的cookies使用可以使用chrome插件 editThisCookie 对于开发者来说一定要妥善保存application.secret,最好不要直接保存到application.conf中。可以考虑线上环境作为参数启动程序，或者用线上的配置覆盖application.conf.","tags":[{"name":"scala","slug":"scala","permalink":"http://decodezero.cn/tags/scala/"},{"name":"play","slug":"play","permalink":"http://decodezero.cn/tags/play/"}]},{"title":"Android常用网络请求框架简析","date":"2017-10-24T07:03:47.000Z","path":"2017/10/24/android常用网络请求框架简析.html","text":"Android常用网络请求框架简析目录 框架做什么 常用请求方式 Retrofit简析 框架做什么网络请求框架是为了方便我们的业务开发而设计的。如果脱离开网络框架可以想象一下Android程序如何发出一个网络请求。需要设置合适的参数（keep-alive，content-type，timeout，get/post等），然后创建一个socket，发出http请求，等待接收响应，解析数据，进行处理。Android还需要一个线程切换，启动一个线程发出请求，handler把结果发送到主线程。上述只是一个网络请求最简单的情况，可能还要涉及复杂的网络请求，上传图片，需要处理缓存，结果异常处理等。 这些都是和业务代码没有关系的网络连接的管理。网络请求框架就是帮我们封装这些细节的处理，使可以通过简单的配置就能进行网络请求。 框架要做的事情 异步请求 线程池 缓存 数据解析 错误处理 等等 一个好的网络请求框架应该可以和业务代码的耦合性尽量降低。 常用请求方式HttpClienthttpClient 在 Android 5.0 被废弃了，在 Android 6.0被删除。在官网中对其做了如下说明：“Android 6.0 release removes support for the Apache HTTP client. If your app is using this client and targets Android 2.3 (API level 9) or higher, use the HttpURLConnection class instead. This API is more efficient because it reduces network use through transparent compression and response caching, and minimizes power consumption.” HttpURLConnection一个轻量级的 http 请求客户端，谷歌官方支持的，提供的 api 比较简单，比较容易使用和扩展。 okhttpokhttp是一个高性能的http请求框架。支持同步get，异步get，post请求，提交文件，提交分块请求，可以响应缓存，取消一个请求，连接、读取、写入超时，处理验证等。okhttp底层流处理是基于okio，它补充了 java.io 和 java.nio 的内容，使得数据访问、存储和处理更加便捷。 volleyvolley是谷歌官方支持的。Android 版本大于9使用HttpURLConnection，小于9使用 HttpClient 进行通信。不支持 post 大数据，所以不适合上传文件。不过 Volley 设计的初衷本身也就是为频繁的、数据量小的网络请求而生 不过在现在17年10月份来看volley更新并不太活跃了 可以通过源码来分析一下volley的是如何将网络请求发送出去的。在其中的一些细节，可以让我门对volley的一些性质有更深入的了解。 volley需要调用Volley类中的静态方法newRequestQueue来生成一个requestQueue来管理执行的网络请求。 12345678910111213141516171819202122232425262728public static RequestQueue newRequestQueue(Context context, HttpStack stack) &#123; File cacheDir = new File(context.getCacheDir(), DEFAULT_CACHE_DIR); String userAgent = \"volley/0\"; try &#123; String packageName = context.getPackageName(); PackageInfo info = context.getPackageManager().getPackageInfo(packageName, 0); userAgent = packageName + \"/\" + info.versionCode; &#125; catch (NameNotFoundException e) &#123; &#125; if (stack == null) &#123; if (Build.VERSION.SDK_INT &gt;= 9) &#123; stack = new HurlStack(); &#125; else &#123; // Prior to Gingerbread, HttpUrlConnection was unreliable. // See: http://android-developers.blogspot.com/2011/09/androids-http-clients.html stack = new HttpClientStack(AndroidHttpClient.newInstance(userAgent)); &#125; &#125; Network network = new BasicNetwork(stack); RequestQueue queue = new RequestQueue(new DiskBasedCache(cacheDir), network); queue.start(); return queue; &#125; 可以看其中的 if (Build.VERSION.SDK_INT &gt;= 9)这句起，是Android 版本大于9使用HttpURLConnection，小于9使用 HttpClient 进行通信的具体实现。创建的requestQueue有一个Network的对象。执行到最后是queue.start()。看一下具体实现。 1234567891011121314151617/** * Starts the dispatchers in this queue. */ public void start() &#123; stop(); // Make sure any currently running dispatchers are stopped. // Create the cache dispatcher and start it. mCacheDispatcher = new CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery); mCacheDispatcher.start(); // Create network dispatchers (and corresponding threads) up to the pool size. for (int i = 0; i &lt; mDispatchers.length; i++) &#123; NetworkDispatcher networkDispatcher = new NetworkDispatcher(mNetworkQueue, mNetwork, mCache, mDelivery); mDispatchers[i] = networkDispatcher; networkDispatcher.start(); &#125; &#125; 这段程序中启了一个 CacheDispatcher 线程用来处理缓存的请求，启动mDispatchers.length 个 NetworkDispatcher 用来处理实际发送的网络请求，默认是四个，NetworkDispatcher 有一个 Network对象是最后请求的实际发送者。这五个线程会一直在后台运行。实际网络请求的线程数量有多个，且可以配置是volley可以同时发送大量的请求的网络请求的原因之一。 执行的五个线程准备好了之后，等待requestQueue.add方法加入需要执行的request 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Adds a Request to the dispatch queue. * @param request The request to service * @return The passed-in request */ public &lt;T&gt; Request&lt;T&gt; add(Request&lt;T&gt; request) &#123; // Tag the request as belonging to this queue and add it to the set of current requests. request.setRequestQueue(this); synchronized (mCurrentRequests) &#123; mCurrentRequests.add(request); &#125; // Process requests in the order they are added. request.setSequence(getSequenceNumber()); request.addMarker(\"add-to-queue\"); // If the request is uncacheable, skip the cache queue and go straight to the network. if (!request.shouldCache()) &#123; mNetworkQueue.add(request); return request; &#125; // Insert request into stage if there's already a request with the same cache key in flight. synchronized (mWaitingRequests) &#123; String cacheKey = request.getCacheKey(); if (mWaitingRequests.containsKey(cacheKey)) &#123; // There is already a request in flight. Queue up. Queue&lt;Request&lt;?&gt;&gt; stagedRequests = mWaitingRequests.get(cacheKey); if (stagedRequests == null) &#123; stagedRequests = new LinkedList&lt;Request&lt;?&gt;&gt;(); &#125; stagedRequests.add(request); mWaitingRequests.put(cacheKey, stagedRequests); if (VolleyLog.DEBUG) &#123; VolleyLog.v(\"Request for cacheKey=%s is in flight, putting on hold.\", cacheKey); &#125; &#125; else &#123; // Insert 'null' queue for this cacheKey, indicating there is now a request in // flight. mWaitingRequests.put(cacheKey, null); mCacheQueue.add(request); &#125; return request; &#125; &#125; 这段代码会判断当前请求配置的是否可以缓存，如果不可以缓存则直接加入到 mNetworkQueue 中，如果可以缓存则将请求加入到 mCacheQueue 。CacheDispatcher 会监听mCacheQueue。NetworkDispatcher会监听 mNetworkQueue。 在 CacheDispatcher 中会查找放入 mCacheQueue 的请求是否有缓存。如果缓存命中，返回结果，如果未命中放入 mNetworkQueue 中，看一下 NetworkDispatcher 的 run 方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public void run() &#123; Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); while (true) &#123; long startTimeMs = SystemClock.elapsedRealtime(); Request&lt;?&gt; request; try &#123; // Take a request from the queue. request = mQueue.take(); &#125; catch (InterruptedException e) &#123; // We may have been interrupted because it was time to quit. if (mQuit) &#123; return; &#125; continue; &#125; try &#123; request.addMarker(\"network-queue-take\"); // If the request was cancelled already, do not perform the // network request. if (request.isCanceled()) &#123; request.finish(\"network-discard-cancelled\"); continue; &#125; addTrafficStatsTag(request); // Perform the network request. NetworkResponse networkResponse = mNetwork.performRequest(request); request.addMarker(\"network-http-complete\"); // If the server returned 304 AND we delivered a response already, // we're done -- don't deliver a second identical response. if (networkResponse.notModified &amp;&amp; request.hasHadResponseDelivered()) &#123; request.finish(\"not-modified\"); continue; &#125; // Parse the response here on the worker thread. Response&lt;?&gt; response = request.parseNetworkResponse(networkResponse); request.addMarker(\"network-parse-complete\"); // Write to cache if applicable. // TODO: Only update cache metadata instead of entire record for 304s. if (request.shouldCache() &amp;&amp; response.cacheEntry != null) &#123; mCache.put(request.getCacheKey(), response.cacheEntry); request.addMarker(\"network-cache-written\"); &#125; // Post the response back. request.markDelivered(); mDelivery.postResponse(request, response); &#125; catch (VolleyError volleyError) &#123; volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs); parseAndDeliverNetworkError(request, volleyError); &#125; catch (Exception e) &#123; VolleyLog.e(e, \"Unhandled exception %s\", e.toString()); VolleyError volleyError = new VolleyError(e); volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs); mDelivery.postError(request, volleyError); &#125; &#125; &#125; 可以关注这句话 NetworkResponse networkResponse = mNetwork.performRequest(request); 这句执行了具体的网络请求。读一下它的代码，看看其对网络请求的发送如何处理。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public NetworkResponse performRequest(Request&lt;?&gt; request) throws VolleyError &#123; long requestStart = SystemClock.elapsedRealtime(); while (true) &#123; HttpResponse httpResponse = null; byte[] responseContents = null; Map&lt;String, String&gt; responseHeaders = Collections.emptyMap(); try &#123; // Gather headers. Map&lt;String, String&gt; headers = new HashMap&lt;String, String&gt;(); addCacheHeaders(headers, request.getCacheEntry()); httpResponse = mHttpStack.performRequest(request, headers); StatusLine statusLine = httpResponse.getStatusLine(); int statusCode = statusLine.getStatusCode(); responseHeaders = convertHeaders(httpResponse.getAllHeaders()); // Handle cache validation. if (statusCode == HttpStatus.SC_NOT_MODIFIED) &#123; Entry entry = request.getCacheEntry(); if (entry == null) &#123; return new NetworkResponse(HttpStatus.SC_NOT_MODIFIED, null, responseHeaders, true, SystemClock.elapsedRealtime() - requestStart); &#125; // A HTTP 304 response does not have all header fields. We // have to use the header fields from the cache entry plus // the new ones from the response. // http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.5 entry.responseHeaders.putAll(responseHeaders); return new NetworkResponse(HttpStatus.SC_NOT_MODIFIED, entry.data, entry.responseHeaders, true, SystemClock.elapsedRealtime() - requestStart); &#125; // Some responses such as 204s do not have content. We must check. if (httpResponse.getEntity() != null) &#123; responseContents = entityToBytes(httpResponse.getEntity()); &#125; else &#123; // Add 0 byte response as a way of honestly representing a // no-content request. responseContents = new byte[0]; &#125; // if the request is slow, log it. long requestLifetime = SystemClock.elapsedRealtime() - requestStart; logSlowRequests(requestLifetime, request, responseContents, statusLine); if (statusCode &lt; 200 || statusCode &gt; 299) &#123; throw new IOException(); &#125; return new NetworkResponse(statusCode, responseContents, responseHeaders, false, SystemClock.elapsedRealtime() - requestStart); &#125; catch (SocketTimeoutException e) &#123; attemptRetryOnException(\"socket\", request, new TimeoutError()); &#125; catch (ConnectTimeoutException e) &#123; attemptRetryOnException(\"connection\", request, new TimeoutError()); &#125; catch (MalformedURLException e) &#123; throw new RuntimeException(\"Bad URL \" + request.getUrl(), e); &#125; catch (IOException e) &#123; int statusCode = 0; NetworkResponse networkResponse = null; if (httpResponse != null) &#123; statusCode = httpResponse.getStatusLine().getStatusCode(); &#125; else &#123; throw new NoConnectionError(e); &#125; VolleyLog.e(\"Unexpected response code %d for %s\", statusCode, request.getUrl()); if (responseContents != null) &#123; networkResponse = new NetworkResponse(statusCode, responseContents, responseHeaders, false, SystemClock.elapsedRealtime() - requestStart); if (statusCode == HttpStatus.SC_UNAUTHORIZED || statusCode == HttpStatus.SC_FORBIDDEN) &#123; attemptRetryOnException(\"auth\", request, new AuthFailureError(networkResponse)); &#125; else &#123; // TODO: Only throw ServerError for 5xx status codes. throw new ServerError(networkResponse); &#125; &#125; else &#123; throw new NetworkError(networkResponse); &#125; &#125; &#125; &#125; 这些代码里面重点看 httpResponse = mHttpStack.performRequest(request, headers); 这句是调用 mHttpStack 即最开始封装的HttpURLConnection或者HttpClient发送具体请求，往下部分是对httpResponse结果的处理。关于结果处理重点看 responseContents = entityToBytes(httpResponse.getEntity()); 这句通过entityToBytes方法将原entity转换成了byte[]。看一下具体的实现 1234567891011121314151617181920212223242526272829/** Reads the contents of HttpEntity into a byte[]. */ private byte[] entityToBytes(HttpEntity entity) throws IOException, ServerError &#123; PoolingByteArrayOutputStream bytes = new PoolingByteArrayOutputStream(mPool, (int) entity.getContentLength()); byte[] buffer = null; try &#123; InputStream in = entity.getContent(); if (in == null) &#123; throw new ServerError(); &#125; buffer = mPool.getBuf(1024); int count; while ((count = in.read(buffer)) != -1) &#123; bytes.write(buffer, 0, count); &#125; return bytes.toByteArray(); &#125; finally &#123; try &#123; // Close the InputStream and release the resources by \"consuming the content\". entity.consumeContent(); &#125; catch (IOException e) &#123; // This can happen if there was an exception above that left the entity in // an invalid state. VolleyLog.v(\"Error occured when calling consumingContent\"); &#125; mPool.returnBuf(buffer); bytes.close(); &#125; &#125; 可以重点看这句实现buffer = mPool.getBuf(1024); 这一句从 mPool 中取得一个 buffer ，然后将 entity 的内容写入这个 buffer 中。这个 mPool 是类 ByteArrayPool 的一个对象。ByteArrayPool 是一个字节数组缓存池。是用来缓存网络请求获得的数据。这个缓存池设置的目的就是方便缓存频繁的网络请求返回的结果，不然需要频繁的申请内存，释放内存，gc。频繁GC对客户端的性能有直接影响。ByteArrayPool 利用 mBuffersByLastUse 和 mBuffersBySize 完成字节数组的缓存，提供 getBuf 和 returnBuf的方法。当需要使内存区域的时候，先从已经分配的区域中获得以减少内存分配次数。当空间用完以后，再将数据返回给此缓冲区。 通过ByteArrayPool的使用，可以看到Volley所有的网络请求结果均是在缓存在内存中，可以很方便的频繁发送小的请求，但是对于一些大数据量的请求，会将这个缓存占满，所以volley不支持post大数据 总结一下，volley有三类线程，MainThread、CacheDispatcher线程、NetworkDispatcher线程。volley 使用 RequestQueue 管理执行网络操作的工作线程。在主线程中调用 RequestQueue 的 add()方法来添加一条网络请求，这条请求会先被加入到缓存队列当中，如果发现可以找到相应的缓存结果就直接读取缓存并解析，然后回调给主线程。如果在缓存中没有找到结果，则将这条请求加入到网络请求队列中，然后处理发送HTTP请求，解析响应结果，写入缓存，并回调主线程。HTTP请求响应的结果会转换成byte[],使用ByteArrayPool这个对象来管理到缓存中，减少内存分配，释放次数。 RetrofitRetrofit和okhttp一样是Square的开源项目。相比较volley，retrofit解耦的更加彻底。 使用注解来描述http请求 请求方法注解 请求头注解 请求和响应格式注解 请求参数注解 以下是部分在接口HttpService中的代码，声明了一些接口 12345678910111213//用户问题反馈接口 @FormUrlEncoded @POST(\"/api/1.0/feedBack\") Observable&lt;BaseHttpResult&lt;JsonObject&gt;&gt; feedBack(@FieldMap Map&lt;String, String&gt; map); //上传图片接口 @Multipart @POST(\"/api/1.0/upload\") Observable&lt;BaseHttpResult&lt;ImageUploadBean&gt;&gt; uploadImage(@PartMap Map&lt;String, MultipartBody.Part&gt; map); //获取消息列表 @GET(\"/api/1.0/messages\") Observable&lt;BaseHttpResult&lt;List&lt;MessageBean&gt;&gt;&gt; getMessageList(@Query(\"userID\") String userId); 可以配置不同的请求适配器，比如RxJava，Java8，Guava；可以配置不同的反序列化工具，比如json，protobuff，xml等；也可以配置不同的http请求客户端，默认使用okhttp。 12345678910111213141516171819// http请求客户端client = new OkHttpClient .Builder() .addInterceptor(addQueryParameterInterceptor()) //参数添加 .addInterceptor(addHeaderInterceptor()) // token过滤 .addInterceptor(httpLoggingInterceptor) //日志,所有的请求响应度看到 .cache(cache) //添加缓存 .connectTimeout(60l, TimeUnit.SECONDS) .readTimeout(60l, TimeUnit.SECONDS) .writeTimeout(60l, TimeUnit.SECONDS) .build();// 获取retrofit的实例retrofit = new Retrofit .Builder() .baseUrl(baseUrl) //配置baseurl .client(client) //配置http请求客户端 .addCallAdapterFactory(RxJavaCallAdapterFactory.create()) //配置请求适配器，这里用Rxjava .addConverterFactory(GsonConverterFactory.create()) //配置反序列化工具，这里用Gson .build(); 在上面的示例代码中可以看到retrofit的网络请求部分依赖于okhttp，okhttp完成缓存，超时时间，日志拦截器配置等；请求的适配器，反序列化工具也是配置的其他开源工具。retrofit只负责一个架构组织的工作，将网络请求中用到的各个模块灵活的拼装起来，可以方便的更换各个组件。贯彻了单一职责的原则。 设计模式的使用 retrofit如此灵活的配置，主要得益于它的架构设计中使用了大量的设计模式。 retrofit的源码可以说是设计模式的教科书，上面这张图中只列出了在retrofit中应用的部分设计模式，一些基本的如工厂模式，单例模式等，并未列出。 在retrofit中请求的适配器，反序列化工具的配置部分都用到了适配器模式。 其实适配器模式并不复杂,合理的使用会对代码的灵活性带来很大的收益。下图是适配器模式的类图。 我们来分析一下retrofit如何通过适配器模式来方便的切换不同的请求适配器。 retrofit的发送网络请求一般只需要两行代码 12HttpService httpService = retrofit.create(GitHubService.class);//获得HttpService的一个实现类Observable&lt;BaseHttpResult&lt;List&lt;MessageBean&gt;&gt;&gt; messagetList = httpService.getMessageList(\"123\") //调用上文的getMessageList方法 我们跟进retrofit的create方法 123456789101112131415161718192021222324public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123; Utils.validateServiceInterface(service); if (validateEagerly) &#123; eagerlyValidateMethods(service); &#125; return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;, new InvocationHandler() &#123; private final Platform platform = Platform.get(); @Override public Object invoke(Object proxy, Method method, Object... args) throws Throwable &#123; // If the method is a method from Object then defer to normal invocation. if (method.getDeclaringClass() == Object.class) &#123; return method.invoke(this, args); &#125; if (platform.isDefaultMethod(method)) &#123; return platform.invokeDefaultMethod(method, service, proxy, args); &#125; ServiceMethod serviceMethod = loadServiceMethod(method); OkHttpCall okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args); return serviceMethod.callAdapter.adapt(okHttpCall); &#125; &#125;); &#125; 在这个实现里，创建api HttpService 的实现实例使用到了动态代理。 我们重点分析最后面的三行代码。 第一行 ServiceMethod serviceMethod = loadServiceMethod(method); ServiceMethod 这个类的第一行注释很好的诠释了这个类的作用, 将一个 api 方法转换成为一个 http 请求。 12345678910111213141516171819202122232425262728293031323334353637/** Adapts an invocation of an interface method into an HTTP call. */final class ServiceMethod&lt;T&gt; &#123; // Upper and lower characters, digits, underscores, and hyphens, starting with a character. static final String PARAM = \"[a-zA-Z][a-zA-Z0-9_-]*\"; static final Pattern PARAM_URL_REGEX = Pattern.compile(\"\\\\&#123;(\" + PARAM + \")\\\\&#125;\"); static final Pattern PARAM_NAME_REGEX = Pattern.compile(PARAM); final okhttp3.Call.Factory callFactory; final CallAdapter&lt;?&gt; callAdapter; private final HttpUrl baseUrl; private final Converter&lt;ResponseBody, T&gt; responseConverter; private final String httpMethod; private final String relativeUrl; private final Headers headers; private final MediaType contentType; private final boolean hasBody; private final boolean isFormEncoded; private final boolean isMultipart; private final ParameterHandler&lt;?&gt;[] parameterHandlers; ServiceMethod(Builder&lt;T&gt; builder) &#123; this.callFactory = builder.retrofit.callFactory(); this.callAdapter = builder.callAdapter; this.baseUrl = builder.retrofit.baseUrl(); this.responseConverter = builder.responseConverter; this.httpMethod = builder.httpMethod; this.relativeUrl = builder.relativeUrl; this.headers = builder.headers; this.contentType = builder.contentType; this.hasBody = builder.hasBody; this.isFormEncoded = builder.isFormEncoded; this.isMultipart = builder.isMultipart; this.parameterHandlers = builder.parameterHandlers; &#125; ... 在这里我们主要分析 ServiceMethod 中的两个成员 callAdapter 和 parameterHandlers 。callAdapter 是我们在 build retrofit 时候 addCallAdapterFactory(RxJavaCallAdapterFactory.create()) 提供的。parameterHandlers 由 ServiceMethod 中parseParameter 这个函数生成，负责对注解进行处理，构造为 http 请求。所以我们才可以在最开始方便的使用注解的方式来描述 http 请求。想了解注解如何处理的可以详细看一下parameterHandlers相关的函数 第二行 OkHttpCall okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args)OkHttpCall执行具体的网络请求，并解析返回数据。OkHttpCall中进行网络请求的方法主要有两个： execute()执行同步请求，enqueue(Callback callback) 执行异步请求。 第三行 return serviceMethod.callAdapter.adapt(okHttpCall) 回到了最开始说的适配器模式的使用， 这句话相当于上面类图中的client。 所有的 callAdapter 都实现接口 CallAdapter，CallAdapter 相当于类图中的Target 默认的 DefaultCallAdapterFactory 生成的 callAdapter 直接将 Call 返回，相当于类图中的 Adapter。 retfofit 中自带的 ExecutorCallAdapterFactory，这个工厂类生成的 CallAdapter 类将 Call 适配成 ExecutorCallbackCall，ExecutorCallbackCall 可以支持回调。 123@Override public &lt;R&gt; Call&lt;R&gt; adapt(Call&lt;R&gt; call) &#123; return new ExecutorCallbackCall&lt;&gt;(callbackExecutor, call);&#125; 这是一个上述类图中Adaptee的实现 RxJavaCallAdapterFactory，工厂类生成的 SimpleCallAdapter 实现了CallAdapter，将 Call 适配成 Observable，可以用 rxjava 进行相关操作，线程切换等，SimpleCallAdapter 也是上述类图中Adaptee的一种实现。 12345678@Override public &lt;R&gt; Observable&lt;R&gt; adapt(Call&lt;R&gt; call) &#123;Observable&lt;R&gt; observable = Observable.create(new CallOnSubscribe&lt;&gt;(call)) .lift(OperatorMapResponseToBodyOrError.&lt;R&gt;instance()); if (scheduler != null) &#123; return observable.subscribeOn(scheduler); &#125; return observable;&#125; 总结一下，retrofit 的特点是解耦的更加彻底。其解耦做的好的原因是因为它应用了大量的设计模式。我们分析了其 callAdatper 上面适配器模式的使用，我们可以实现或者包装自己的请求适配器，实现 CallAdaptet 这个接口，并通过相应的 AdapterFactory 类集成到retrofit 中使用。通过这个分析应该对于 retrofit 网络请求的发送过程也有了进一步的了解。 ReferenceRetrofit分析-漂亮的解耦套路 Android Volley完全解析(四) Google Andorid developer doc","tags":[{"name":"android","slug":"android","permalink":"http://decodezero.cn/tags/android/"}]},{"title":"图解http读书笔记1","date":"2016-12-10T00:08:08.000Z","path":"2016/12/10/图解http读书笔记1.html","text":"这是自己读图解http的读书笔记，没有读 TCP/IP详解 卷1是因为考虑到自己的时间，想碰到具体深入底层的问题时再去查阅。这篇包含了http报文首部和http状态码，这两部分其实放到一起更易贯通。有一些状态码是针对特定首部字段才会出现的。 HTTP报文首部http报文首部分为请求报文和响应报文。请求报文包含请求行，请求首部字段，通用首部字段，实体首部字段；响应报文包含状态行，响应首部字段，通用首部字段，实体首部字段。其中请求行包含方法（get，post等）、URI、HTTP版本，状态行包含HTTP版本、状态码。各个首部字段将具体介绍 通用首部字段 Cache-Control 进行缓存控制。no-cache是为了防止从缓存中返回过期的资源，客户端的请求中包含它表示客户端不会接收缓存过的响应，服务器返回的响应中包含no-cache，缓存服务器不能对资源进行缓存；no-store是不进行缓存；然后就是一些具体的指定缓存期限和认证的指令如max-age、min-fresh等 Connection 主要用作控制不再转发给代理的首部字段和管理持久连接。 HTTP首部将定义成缓存代理和非缓存代理的行为，分成了2种。端到端首部（end-to-end）：此类别的首部会发送到最终的接收目标，且必须保存在缓存生成的响应中，必须被转发。逐跳首部(hop-by-hop)：只对单次转发有效，会因为缓存和代理而不再转发。如果要使用hop-by-hop首部，需要提供Connection首部。Connection,Keep-A live,Proxy -A uthenticate,Proxy -A uthorization,Trailer,TE,Transfer-Encoding,Upgrade这八个是hop-by-hop。 管理持久连接上面主要由Keep-Alive和Close。http／1.1默认的是持久连接，http／1.1之前的默认是非持久连接 Date 创建http报文的日期和时间 Pragma 是http／1.1之前版本的遗留字段，仅作为向后兼容而定义。使用形式如下：Pragma：no-cache。只用在客户端发送的请求中。在http／1.1中直接采用Cache-Control：no-cache，兼容以前版本一般也会加上Pragma：no-cache Trailer 事先说明了在报文主体后记录了哪些首部字段。该首部字段可应用在http／1.1版本分块传输编码时。 Transfer—Encoding 规定了传输报文主体时采用的编码方式，仅对分块传输编码有效。 Upgrade 用于检测http协议及其他协议是否可使用更高的版本进行通信。Upgrade首部字段产生作用的Upgrade对象仅限于客户端和临接服务器。 Via 追踪客户端与服务器之间的请求和响应报文的传输路径。可以避免请求回环的发生，在经过代理时必须附加该首部字段内容。各个代理服务器会往via首部添加自身的服务器信息。 Warning 从http／1.0的Retry-After演变过来的。通常会告知用户一些与缓存相关的问题警告。 请求首部字段 Accept 客户端能够处理的媒体类型及媒体类型的相对优先级。优先级权重范围0-1，默认1.0 Accept-Charset 客户端支持的字符集及字符集的相对优先级。字符集指：iso-8859-5，unicode等 Accept-Encoding 客户端支持的内容编码及内容编码的优先级。内容编码指：gzip，compress，deflate等 Accept-Language 支持语言及语言优先级。 Authorization 认证信息，通常会在收到服务器的401之后，把Authorization及认证信息加入请求中。 Expect 告知服务器，期望出现某种特定行为。服务器无法满足期望，会返回417 From 使用用户代理的用户的电子邮件地址。 Host http／1.1内唯一个必须包含在请求内的首部字段。可以解决一个ip对应多个域名的情况。若服务器未设定主机名，就直接发送一个空值。 If-xxx 一系列条件，只有结果满足条件才会从服务器返回。 Max-Forward 最多转发次数 Proxy-Authorization 客户端和代理之间的认证。 Range 获取部分资源的范围请求。单位是字节。 Referer 请求是从哪个uri过来的（正确拼写应该是Referrer，错误的被沿用了） TE 客户端能处理的传输编码方式及优先级。和Accept-Encoding的区别是用户传输编码 User-Agent 创建请求的浏览器和用户代理名称。 响应首部字段 Accept-Range 告知客户端服务器是否能处理范围请求。可以时为bytes，不能时为none Age 源服务器在多久前创建了响应，代理创建响应时必须加上该字段。单位是秒 ETag 服务器端资源的唯一标识 Location 一般在重定向3xx时，返回新的地址 Proxy-Authenticate 代理服务器所要求的认证信息。 Retry-After 告知客户端多久之后再次发送请求，主要配合503或者3xx使用 Server http服务器信息 Vary 源服务器对代理服务器传达关于使用缓存的一些控制。比如Vary：Accept—Language，则只对含有相同VAccept—Language的请求使用缓存。 WWW-Authenticate 401返回中肯定会带有这个字段，告知客户端需要认证的信息。 实体首部字段包含在请求报文和响应报文中的实体部门所使用的首部，用于补充内容的更新时间等与实体相关的信息 Allow 用于通知客户端能够支持的http方法，当返回时405时，会把支持的http方法写入该字段返回。 Content-Encoding 服务器对实体的主体部分内容的编码方式。如gzip，compress等。 Content—Language 告知客户端，实体主体使用的自然语言 Content-Length 实体主体部分的大小，单位是字节。 Content-Location 给出与报文主体部分对应的uri，和Location不同，比如对于使用Accept-Language的请求，当返回的页面和实际请求的对象不同时，Content-Location会写入实际返回的uri Content-MD5 对报文主体部分执行MD5算法，然后再Base64后的结果 Content—Range 对于客户端的范围请求，告知客户端返回的是哪一部分，如：Content-Range： bytes 5001-10000/10000 Content-Type 实体主体内对象的媒体类型 Expires 缓存服务器在Expires字段指定的时间之前，会一直以缓存的内容来响应。超过指定时间后，会转向源服务器请求资源。当通用首部字段Cache-Control有指定的max-age指令时，会优先处理max-age指令。 Last-Modified 资源最终被修改的时间。 为cookie服务的首部字段cookie没有被编入标准化的http／1.1的RFC2016中。现在使用的是netspace的基准上扩展的 Set-Cookie 用在响应首部字段中，字段包括 | 属性 | 说明 | |:—–|:———| | NAME=VALUE | 赋予cookie的名称和其值 | | expires=DATE | 指定浏览器可以发送Cookie的有效期，若省略，其有效期为浏览器关闭之前 | | path=PATH | 将服务器上的文件目录作为Cookie的适用对象，若省略，默认为文档所在的文件目录，不过这个限制可以避开 | | domain=域名 | Cookie适用对象的域名，若省略，默认为创建Cookie的服务器的域名，采用结尾匹配，如指定为a.com, www.a.com, www2.a.com都可以匹配 | | secure | 仅在https的通信时才发送Cookie，通过 Set-Cookie: name=value; secure指定 | | HttpOnly | 使Cookie不能被JS脚本访问,可以防止XSS，通过 Set-Cookie: name=value; HttpOnly指定 | Cookie 用在请求首部字段中，在请求中包含从服务器接收到的Cookie 其它首部字段 X-Frame-Options 用于控制网站内容在其它web网站的Frame标签内的显示问题，主要为了防止点击劫持（clickjacking）攻击。DENY：拒绝，SAMEORIGIN：仅同源域名下的页面可以加载。 X-XSS-Protexiont 属于http响应首部，控制浏览器XSS防护机制的开关，0:XSS过滤设置无效，1:XSS过滤设置有效 DNT 属于http请求首部，0:同意被追踪，1:拒绝被追踪 P3P 属于http响应首部，利用技术保护个人隐私。 HTTP状态码100-199 用于指定客户端应相应的某些动作。 200-299 用于表示请求成功。 300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。 400-499 用于指出客户端的错误。 500-599 用于支持服务器错误。 100 continue 服务器仅接收到部分请求，但是一旦服务器并没有拒绝该请求，客户端应该继续发送其余的请求 200 ok 请求已成功，请求所希望的响应头或数据体将随此响应返回。 201 Created 请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随Location 头信息返回。 202 Accepted 服务器已接受请求，但尚未处理。 203 Non-authoritative Information 服务器已成功处理了请求，但返回了可能来自另一来源的信息。 204 No Content 服务器已经处理了请求，但没有内容可以返回。浏览器的话显示的页面不更新。 206 Partial Content 客户端进行了范围请求，服务器成功执行了，返回由Content-Range指定范围的实体内容 300 Multiple Choices 服务器根据请求可执行多种操作。服务器可根据请求者 来选择一项操作，或提供操作列表供其选择。 301 Moved Permanently 被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一 302 Found 服务器目前正从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。临时重定向。 303 See Other 请求的资源对应着另一个URI，应使用GET方法定向获取请求的资源。和302很相似，但是标准中要求302和301都不能将post方法改成get方法的，不过大多数浏览器都会这么做。 304 Not Modified 客户端发送附带条件的请求，服务器允许访问资源，但是请求未满足条件表示，服务器资源未改变，可以使用客户端未过期的缓存。客户端发送的附带条件指get方法的请求报文中包含If-Match，If-Modified-Since,If-None-Match,If-Range,If-Unmodified-Since 307 Temporary Redirect 请求的资源现在临时从不同的URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。和302的区别是，会遵照浏览器的标准，不会从post变成get。 400 Bad Request 1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。2、请求参数有误。 401 Unauthorized 未授权，请求页面需要用户名和密码 403 Forbidden 禁止, 服务器拒绝请求 404 Not Found 请求失败，请求所希望得到的资源未被在服务器上发现。 405 Method Not Allowed 指出请求方法(GET, POST, HEAD, PUT, DELETE, 等)对某些特定的资源不允许使用。 406 Not Acceptable 服务器生成的响应客户端无法接受 407 Proxy Authentiacation Required 用户必须首先使用代理服务器进行验证 408 Request Timeout 请求超出了服务器的等待时间 410 Gone 被请求的页面不可用 415 Unsupported Media Type 请求的格式不受请求页面的支持 417 Excepctation Failed 客户端的请求中加入了Expect字段，服务器无法满足 500 Internal Server Error 服务器在执行请求时发生了错误，有可能是存在bug 501 Not Implemented 服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。 502 bad gateway，服务器从上游服务器收到一个无效的相应。错误的网关 503 Service unavailable，服务器临时过载或宕机 504 Gateway timeout 网关超时 505 HTTP_VERSION_NOT_SUPPORTED 服务器并不支持在请求中所标明 HTTP 版本。","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://decodezero.cn/tags/读书笔记/"},{"name":"http","slug":"http","permalink":"http://decodezero.cn/tags/http/"}]},{"title":"react native自定义组件","date":"2016-11-28T00:08:08.000Z","path":"2016/11/28/react-native自定义组件.html","text":"react native在app开发上的一个优势就是组件化开发，当有了足够多的自定义组件后，可以很方便的将这些组件拼装起来，开发效率提高很多。本文中将以一个picker为例子，来讲如何包装一个通用性很强的react native组件。本文的示例源码可以在ReactNativeUIComponents下载。这个项目未来会不断的维护加入更多实用的组件，也力求这个项目可以作为一个react native的示例项目，包含了react native开发中常用的router，navigator，code push等，可以作为参考。 picker的效果 其中picker要展示的内容，百度、搜狗、谷歌等均可以由父组件指定，其样式也可以由父组件指定。 组件包装界面本文封装了一个叫Picker的组件。一般推荐通过定义defaultProps来告诉组件的调用者，可以传入这个组件中的参数有哪些。可以看到可以传入的参数有style：组件样式；animationType：动画类型；transparent：是否透明；modalVisible：是否可见；dataArray：显示的数据；title：标题。可以通过传入这些参数，使这个组件拥有不同的样式，显示不同的数据。 1234567891011121314151617181920static defaultProps = &#123; style: View.propTypes.style, animationType: 'none', transparent: true, modalVisible: true, dataArray: [], title: 'title' &#125;; constructor(props) &#123; super(props); this.state = &#123; dataSource: this._getDataSource(props.dataArray), style: this.props.style, animationType: this.props.animationType, transparent: this.props.transparent, modalVisible: this.props.modalVisible, &#125;; &#125; 组件内部的渲染代码如下，主体是一个Modal，然后是一个整体的view 1&lt;View style=&#123;[styles.modalContainer, &#123;backgroundColor: 'rgba(0, 0, 0, 0.5)'&#125;]&#125;&gt; 在这个view中主要有两部分内容，一个是顶部的title，另一个是底部的listview，title显示从父组件中传入的标题，listview显示传入的dataArray。 12345678910111213141516171819202122232425&lt;Modal animationType=&#123;this.state.animationType&#125; transparent=&#123;this.state.transparent&#125; visible=&#123;this.state.modalVisible&#125; onRequestClose=&#123;() =&gt; &#123;this._setModalVisible(false)&#125;&#125;&gt; &lt;View style=&#123;[styles.modalContainer, &#123;backgroundColor: 'rgba(0, 0, 0, 0.5)'&#125;]&#125;&gt; &lt;View style=&#123;styles.viewContainer&#125;&gt; &lt;View style=&#123;styles.titleRow&#125;&gt; &lt;TouchableOpacity style=&#123;styles.cancelButton&#125; onPress=&#123;() =&gt; &#123;this._setModalVisible(false)&#125;&#125;&gt; &lt;Image style=&#123;styles.image&#125; source=&#123;require('../img/icon_cancel_grey.png')&#125;/&gt; &lt;/TouchableOpacity&gt; &lt;Text style=&#123;[styles.titleText, styles.modalTitle]&#125;&gt;&#123;this.props.title&#125;&lt;/Text&gt; &lt;/View&gt; &lt;View style=&#123;[&#123;marginTop: 0, marginBottom: 0&#125;]&#125;/&gt; &lt;ListView style=&#123;styles.flex&#125; dataSource=&#123;this.state.dataSource&#125; renderRow=&#123;(rowData, sectionID, rowID) =&gt; this._renderRow(rowData, sectionID, rowID)&#125; renderScrollComponent=&#123;props =&gt; &lt;RecyclerViewBackedScrollView &#123;...props&#125; /&gt;&#125; renderSeparator=&#123;(sectionID, rowID) =&gt; &lt;View key=&#123;`$&#123;sectionID&#125;-$&#123;rowID&#125;`&#125; style=&#123;[GlobalStyles.divider, &#123;marginTop: 0, marginBottom: 0, marginLeft: 16&#125;]&#125;/&gt;&#125; /&gt; &lt;/View&gt; &lt;/View&gt;&lt;/Modal&gt; listView中每一个cell的渲染 12345678910111213_renderRow(rowData, sectionID, rowID) &#123; return ( &lt;TouchableHighlight onPress=&#123;() =&gt; this._pressRow(rowData, rowID)&#125; underlayColor='gray'&gt; &lt;View&gt; &lt;View style=&#123;styles.row&#125;&gt; &lt;Text style=&#123;styles.rowTitle&#125;&gt; &#123;rowData.name&#125; &lt;/Text&gt; &lt;/View&gt; &lt;/View&gt; &lt;/TouchableHighlight&gt; ); &#125; 下面是对这个组件调用的一个示例，puperseItems是一个格式化对象的数组，这个对象包含了name,id,url三个属性 123456&lt;Picker title=\"选择搜索引擎\" dataArray=&#123;purposeItems&#125; selectedData=&#123;(purpose) =&gt; &#123;this.onPurposeSelected(purpose);&#125;&#125; onHideModal=&#123;() =&gt; this.setState(&#123;purposeModalVisible: false&#125;)&#125;/&gt; 至此界面的展示完毕 操作 这样一个组件主要有两种操作，点击当前列和关闭modal，如下两个函数，主要是调用了父组件传递进来的selectedData和onHideModal回调 12345678910111213_pressRow(rowData, rowID) &#123; this.props.selectedData &amp;&amp; this.props.selectedData(rowData); this.props.selectedIndex &amp;&amp; this.props.selectedIndex(rowID);&#125;_setModalVisible(visible) &#123; this.setState(&#123;modalVisible: visible&#125;); if (visible) &#123; this.props.onShowModal &amp;&amp; this.props.onShowModal(); &#125; else &#123; this.props.onHideModal &amp;&amp; this.props.onHideModal(); &#125;&#125; 至此完成了一个组件的封装，可以灵活的显示父组件传入的数据，并进行各种交互。 本文的示例源码可以在ReactNativeUIComponents下载","tags":[{"name":"react_native","slug":"react-native","permalink":"http://decodezero.cn/tags/react-native/"}]},{"title":"Android app重新签名和查看已有签名","date":"2016-11-20T00:08:08.000Z","path":"2016/11/20/android-app重新签名和查看已有签名.html","text":"有时候会需要将一个已经签名的Android apk重新签名。比如oppo软件商店的app认领，它会要求你下载一个空包，并将与认领应用一致的签名写入空包中。可以如下操作 删除原apk签名文件1234567mkdir testmv TestSign.apk testcd testjar -xvf TestSign.apk //解压apkrm -rf META-INF //删除META-INFrm -rf TestSign.apk //删除原apkjar -cvf ../TestSign.apk ./ //将当前文件夹中的内容打包成apk到外层文件夹 生成keystore如果打算使用已有keystore，可以不生成，直接进行下一步 1keytool -genkey -v -keystore test.keystore -alias test -keyalg RSA -validity 10000 apk重新签名最后的“test”与上面生成keystore制定的-alias要一致 1jarsigner -verbose -keystore test.keystore -signedjar -TestSigned.apk TestSign.apk test 查看生成的apk的签名12345mkdir testmv TestSigned.apk testcd testjar -xvf TestSign.apk //解压apkkeytool -printcert -file META-INF/xxx.RSA","tags":[{"name":"android","slug":"android","permalink":"http://decodezero.cn/tags/android/"}]},{"title":"react native与android native代码的集成开发","date":"2016-10-29T00:08:08.000Z","path":"2016/10/29/react-native与android-native代码的集成开发.html","text":"这篇文章讲的不是native module相关内容，即如何在react native的js代码中调用androd的native代码。也不是native components相关内容，即如何封装一些原生的组建供react native层使用。这里主要想讲如何在android的应用中，集成react native的页面和如何在react native中启动android activity。这样能达到原生android页面和react native页面互相切换的目的，从而使开发更加灵活。 这篇博客的示例代码在TestRNIntegrationNative可供参考运行 android应用中集成react native这部分内容主要从官方文档Integration With Existing Apps android版本翻译而来，根据自己的理解翻译，不是严格对照原文，加入了一些自己在实践过程中碰到的问题 关键内容react native对于从头建立一些新的app非常好用。它同样可以用于在一个已有app的基础上加入一些页面。通过下面几个步骤，可以在已有的app上加入一些基本的react native的功能，页面，view组建等。 将react native集成到已有andriod app的关键步骤有如下几个： 理解你想要集成react native的哪个组件 在你的Android项目的根目录下安装react-native，创建node_modules目录 用react-native写你需要的组件 在你的build.gradle文件中添加com.facebook.react:react-native:+和指向node_module下react-native的二进制文件的maven引用 在android中写一个activity，这个activity创建一个ReactRootView 打开react-native server，运行app 增加更多的组件 调试 准备 发布 部署优化 下面将详细介绍具体步骤 准备按照getting-started将需要的配置装好 在app中加入js在app的根目录下执行 123npm initnpm install --save react react-nativecurl -o .flowconfig https://raw.githubusercontent.com/facebook/react-native/master/.flowconfig 打开package.json，在scripts中加入 1&quot;start&quot;: &quot;node node_modules/react-native/local-cli/cli.js start&quot; 在index.android.js中加入如下代码，如index.android.js不存在，则在根目录创建一个 12345678910111213141516171819202122232425262728293031'use strict';import React from 'react';import &#123; AppRegistry, StyleSheet, Text, View&#125; from 'react-native';class HelloWorld extends React.Component &#123; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;Text style=&#123;styles.hello&#125;&gt;Hello, World&lt;/Text&gt; &lt;/View&gt; ) &#125;&#125;var styles = StyleSheet.create(&#123; container: &#123; flex: 1, justifyContent: 'center', &#125;, hello: &#123; fontSize: 20, textAlign: 'center', margin: 10, &#125;,&#125;);AppRegistry.registerComponent('HelloWorld', () =&gt; HelloWorld); 配置当前app在app的build.gradle文件中加入如下对react native的依赖 1234dependencies &#123; ... compile &quot;com.facebook.react:react-native:+&quot; // From node_modules.&#125; 如果你想要指定react native的版本，可以将+换成具体的版本号 在工程的build.gradle中指定所依赖的本地react native的地址 12345678910allprojects &#123; repositories &#123; ... maven &#123; // All of React Native (JS, Android binaries) is installed from npm url &quot;$rootDir/node_modules/react-native/android&quot; &#125; &#125; ...&#125; 在AndroidManifest.xml中增加网络访问权限 1&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; 增加native代码需要有native的代码来启动React Native，并开始渲染。我们在android native代码中新建一个activity，ReactActivity，其中创建了ReactRootView。通过它来启动React Native相关程序。 tips1: 如果Android version &lt;5,用com.android.support:appcompat下的AppCompatActivity来取代Activity。 tips2：如果app执行的时候报出Didn’t find class “com.facebook.jni.IteratorHelper”的异常，取消掉setUseOldBridge这句的注释 12345678910111213141516171819202122232425262728public class MyReactActivity extends Activity implements DefaultHardwareBackBtnHandler &#123; private ReactRootView mReactRootView; private ReactInstanceManager mReactInstanceManager; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); mReactRootView = new ReactRootView(this); mReactInstanceManager = ReactInstanceManager.builder() .setApplication(getApplication()) .setBundleAssetName(\"index.android.bundle\") .setJSMainModuleName(\"index.android\") .addPackage(new MainReactPackage()) .setUseDeveloperSupport(BuildConfig.DEBUG) .setInitialLifecycleState(LifecycleState.RESUMED) //.setUseOldBridge(true) // uncomment this line if your app crashes .build(); mReactRootView.startReactApplication(mReactInstanceManager, \"HelloWorld\", null); setContentView(mReactRootView); &#125; @Override public void invokeDefaultOnBackPressed() &#123; super.onBackPressed(); &#125;&#125; 其中的HelloWorld，需要与index.android.js中AppRegistry.registerComponent()的第一个参数匹配 在AndroidManifest.xml中为ReactActivity指定主题。 12345&lt;activity android:name=\".ReactActivity\" android:label=\"@string/app_name\" android:theme=\"@style/Theme.AppCompat.Light.NoActionBar\"&gt;&lt;/activity&gt; 我们需要传递一些callback到ReactInstanceManager中 1234567891011121314151617181920212223242526@Overrideprotected void onPause() &#123; super.onPause(); if (mReactInstanceManager != null) &#123; mReactInstanceManager.onPause(); &#125;&#125;@Overrideprotected void onResume() &#123; super.onResume(); if (mReactInstanceManager != null) &#123; mReactInstanceManager.onResume(this, this); &#125;&#125;@Overrideprotected void onDestroy() &#123; super.onDestroy(); if (mReactInstanceManager != null) &#123; mReactInstanceManager.onDestroy(); &#125;&#125; 传递对退出事件的处理到react native中 12345678@Override public void onBackPressed() &#123; if (mReactInstanceManager != null) &#123; mReactInstanceManager.onBackPressed(); &#125; else &#123; super.onBackPressed(); &#125;&#125; 这将允许JavaScript可以控制用户按下物理退出键时的处理。如果JS层没有特殊处理，会调用默认的invokeDefaultOnBackPressed，关闭当前默认的activity。 然后我们需要增加React Native开发的调试菜单。默认React Native是通过摇手机来调出调试菜单的，但是在模拟器上却不能实现。所有我们设置当按android的物理菜单键时，出现React Native 的开发调试菜单（也可以按Ctrl + M） 12345678@Overridepublic boolean onKeyUp(int keyCode, KeyEvent event) &#123; if (keyCode == KeyEvent.KEYCODE_MENU &amp;&amp; mReactInstanceManager != null) &#123; mReactInstanceManager.showDevOptionsDialog(); return true; &#125; return super.onKeyUp(keyCode, event);&#125; 运行app在你已有的app中的某个activity里可以启动我们的ReactActivity了。像这样 123456789101112131415161718public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button bt = (Button)findViewById(R.id.gotoRN); bt.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Intent intent = new Intent(); intent.setClass(MainActivity.this, ReactActivity.class); startActivity(intent); MainActivity.this.finish(); &#125; &#125;); &#125;&#125; 打开React Native dev server。在根目录运行 1npm start 然后在android studio里像往常一样运行app就可以了 tips1: 如果你使用Android Studio来build这个项目，需要在运行npm start之前安装watchman,可以防止Android Studio和React Native包冲突引起的崩溃 运行如图 用Android Studio打包发布相比较于普通的app打包，要多了一个步骤，在用Android Studio打包之前，执行如下命令生成React Native的bundle。把路径替换成你的真实路径 1$ react-native bundle --platform android --dev false --entry-file index.android.js --bundle-output android/com/your-company-name/app-package-name/src/main/assets/index.android.bundle --assets-dest android/com/your-company-name/app-package-name/src/main/res/ 在react native的JavaScript代码中启动activtiy实现的核心是在native层封装一个Java的方法供JavaScript调用，封装native module。这个Java方法提供了启动其他activity的功能。 增加native代码首先新建一个Module，这个module中封装了启动一个native activity的方法gotoMainActivity 1234567891011121314151617181920public class NativeActivityModule extends ReactContextBaseJavaModule &#123; public NativeActivityModule(ReactApplicationContext reactContext) &#123; super(reactContext); &#125; @Override public String getName() &#123; return \"GotoActivity\"; &#125; @ReactMethod public void gotoMainActivity() &#123; Activity currentActivity = getCurrentActivity(); Intent intent = new Intent(currentActivity, MainActivity.class); currentActivity.startActivity(intent); currentActivity.finish(); &#125;&#125; 新建一个package封装这个module 1234567891011121314151617181920public class NativeActivityPackage implements ReactPackage &#123; @Override public List&lt;NativeModule&gt; createNativeModules(ReactApplicationContext reactContext) &#123; List&lt;NativeModule&gt; modules = new ArrayList&lt;&gt;(); modules.add(new NativeActivityModule(reactContext)); return modules; &#125; @Override public List&lt;ViewManager&gt; createViewManagers(ReactApplicationContext reactContext) &#123; return Collections.emptyList(); &#125; @Override public List&lt;Class&lt;? extends JavaScriptModule&gt;&gt; createJSModules() &#123; return Collections.emptyList(); &#125;&#125; 将这个NativeActivityPackage，增加到我们之前创建的ReactActivity中，主要是对mReactInstanceManager增加一个package，addPackage(new NativeActivityPackage()) 123456789101112131415161718protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); mReactRootView = new ReactRootView(this); mReactInstanceManager = ReactInstanceManager.builder() .setApplication(getApplication()) .setBundleAssetName(\"index.android.bundle\") .setJSMainModuleName(\"index.android\") .addPackage(new MainReactPackage()) .setUseDeveloperSupport(BuildConfig.DEBUG) .setInitialLifecycleState(LifecycleState.RESUMED) .addPackage(new NativeActivityPackage()) //.setUseOldBridge(true) // uncomment this line if your app crashes .build(); mReactRootView.startReactApplication(mReactInstanceManager, \"HelloWorld\", null); setContentView(mReactRootView); &#125;&#125; 在JavaScript层中调用封装的方法12345const GotoActivity = NativeModules.GotoActivity;&lt;TouchableOpacity style=&#123;styles.button&#125; onPress=&#123;() =&gt; &#123;GotoActivity.gotoMainActivity()&#125;&#125;&gt; &lt;Text style=&#123;styles.gotoNative&#125;&gt;Goto Native&lt;/Text&gt;&lt;/TouchableOpacity&gt; 至此我们完成了在android的应用中，集成react native的页面和如何在react native中启动android activity，这样能达到原生android页面和react native页面互相切换的目的。这篇博客的示例代码在TestRNIntegrationNative可供参考运行","tags":[{"name":"android","slug":"android","permalink":"http://decodezero.cn/tags/android/"},{"name":"react_native","slug":"react-native","permalink":"http://decodezero.cn/tags/react-native/"}]},{"title":"Jekyll搭建博客并添加百度统计","date":"2016-10-25T00:08:08.000Z","path":"2016/10/25/Jekyll搭建博客并添加百度统计.html","text":"自己的这个博客是在gitpage上用Jekyll搭建起来的，使用的是这个模版。搭建以后一直是在github上build的，也没有添加点击统计的工具。下面介绍一下自己完成这本地build和添加百度统计的过程和遇到的问题。 添加百度统计现在有很多站长工具可以统计网站的点击量。添加方式大同小异。我添加的是百度统计。注册添加后，会得到如下一段javaScript： 123456789&lt;script&gt; var _hmt = _hmt || [];(function() &#123; var hm = document.createElement(\"script\"); hm.src = \"//hm.baidu.com/hm.js?xxxxxxxxxxxxxxxxxxxxxxxxxxx\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s);&#125;)();&lt;/script&gt; 需要将这段代码添加到网站全部页面的head标签前。对于Jekyll的网站来说可以通过以下三个步骤来实现： 修改_config.yml，加入 1baidu-analysis： xxxxxxxxxxxxxxxxxxxxxxxxxxx 在_include中新建文件baidu-anaylysis.html加入以下代码 123456789&lt;script&gt; var _hmt = _hmt || []; (function() &#123; var hm = document.createElement(\"script\"); hm.src = \"//hm.baidu.com/hm.js?&#123;&#123; site.baidu-analyisis &#125;&#125;\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); &#125;)();&lt;/script&gt; 在博客的入口网页中添加 Jekyll的入口一般在 _layouts/default.html中。我的模版因为将header统一抽取了出来，加在了_includes/head.html中。 在百度统计的网站中心tab中检查首页代码状态，显示代码安装正确，就成功了。 本地build Jekyll123gem install bundlerbundle installbundle exec jekyll serve 注意在config_yml中不能有tab，否则会提示‘found character that cannot start any token while scanning for the next token at line’的错误。 本地server启动后可以在http://localhost:4000/ 访问","tags":[{"name":"tools","slug":"tools","permalink":"http://decodezero.cn/tags/tools/"}]},{"title":"react native related problems and solutions","date":"2016-08-09T00:08:08.000Z","path":"2016/08/09/react-native-related-problems-and-solutions.html","text":"将用博客来记录自己在react native开发过程中遇到的问题，这篇主要侧重于配置过程中用到的问题。这种问题可能只需要一个合适的答案，找寻这个答案可能需要花费半天的工作时间，甚至更久。 error: could not install smartsocket listener: Address already in use 解决方法：genymotion的adb设置Android sdk cant find local.properties 解决方法：手动添加文件，然后sdk.dir=xx Undefined symbols for architecture x86_64: “std::terminate()” 解决方法：I ran in to this issue as well, and the solution @charpeni proposed solved the issue. To be clear for others, if you are upgrading to 0.26+ then you need to make the following changes. In ios/YourProject.xcodeproj/project.pbxproj, look for the two lines like OTHER_LDFLAGS = “-ObjC”;. Replace them with the following: 1234 OTHER_LDFLAGS = ( \"-ObjC\", \"-lc++\",); react-native run-android时出现Could not download imagepipeline.aar 解决方法：修改build.gradle的版本，com.android.tools.build:gradle:2.1.0，改为更高的，然后更改gradle/wrapper/gradle-wrapper.properties中相应的gradle-2.10-all.zip。 Application ReactExample has not been registered. This is either due to a require() error during initialization or failure to call AppRegistry.registerComponent. 解决方法： 关掉其他react-native server和node进程 realm对于schema的更新需要重新启动应用，如果应用已经在本地数据库中写入了数据，则需要将应用删除，重装，因为schema和已有数据会存在冲突。 自己react-native init test.然后测试realm。在ios端总是提示‘Cannot read property ‘debugHosts’ of undefined’ 和‘Module AppRegistry is not a registered callable module’ 解决方法：是rnpm的问题，对于ios项目来说，project name中不能有excample和test,需要在packaje.json中加入。但是自己测试并没有成功。测试将project name命名为其他可以。Realm团队称在下一个版本中会修复这个问题 12345\"rnpm\": &#123; \"ios\": &#123; \"project\": \"ios/&lt;project-name&gt;.xcodeproj\" &#125;&#125; 对于andorid新建的包含realm的rn项目中还会有’Missing Realm constructor-please ensure RealmReact framework is included’的问题 解决方法是在MainApplication.java中添加如下两行 12345678import io.realm.react.RealmReactPackage; // ADD THIS @Override protected List&lt;ReactPackage&gt; getPackages() &#123; return Arrays.&lt;ReactPackage&gt;asList( new MainReactPackage(), new RealmReactPackage() // AND THIS ); &#125; 如在android中出现“Project with path ‘:realm’ could not be found in project ‘:app’. realm”的问题，则需要在setting.gradle中添加 12include ':realm'project(':realm').projectDir = new File(settingsDir, '../node_modules/realm/android') react native realm的可视化官方文档中只介绍了Objective-C，Java，Swift中有realm的可视化工具Realm Browser（暂时只支持mac），在react native中也可以使用。 12console.log(db.path);//输出realm在模拟器上存储的目录adb pull /data/data/&lt;packagename&gt;/files/ . //从模拟器上或者真机（需要root）拉取realm文件 用Realm Browser打开即可，默认名字是default.realm 在./gradlew assembleRelease的时候报错：Execution failed for task ‘:app:bundleReleaseJsAndAssets’. A problem occurred starting process ‘command ‘node’’ 执行 1./gradlew --stop 停掉后台deamon进程，重新打包即可。 react native unable to resolve module react/lib/ReactUpdates 在facebook issue 4968中对这个问题有一些讨论，但是我试了较为普遍的回答： 12watchman watch-del-allnpm cache clean &amp;&amp; npm install 对于我的情况并不生效。后来发现是由于react-native和react版本不匹配造成的。执行 1npm install react@~15.3.1 --save 问题fix，15.3.1是对于我比较合适的版本 运行时出现错误Got JS Exception: ReferenceError: Can’t find variable: process，并在npm install时提示react-native@0.35.0 requires a peer of react@~15.3.1 but none was installed. 这个问题同样是因为react的版本不对执行 1npm install react@~15.3.1 --save 问题fix","tags":[{"name":"react_native","slug":"react-native","permalink":"http://decodezero.cn/tags/react-native/"}]},{"title":"react native 痛点与优势","date":"2016-08-09T00:08:08.000Z","path":"2016/08/09/react-native痛点与优势.html","text":"随着自己对react native开发的深入，对于其一些痛点和优势也有着更深的体会 react native的痛点 由于还不是稳定版本，版本更新太快，大概两周会有一个新的版本。更新新版可能会出现不兼容的问题，有时候需要手动解决。 支持的组件不全面。大部分厂商并不支持react native。一些支持的现在一般也处在不稳定版本。比如截止到rn版本0.35，js版的本地数据库组件只有realm支持，现在realm版本为0.15，很多功能不全。 程序的性能。现在普遍都说比原生的性能要差，但是差多少没有一个具体的衡量。直观的感觉是复杂的页面在一些配置较低的手机上会有肉眼可见卡顿的感觉。 虽然大多界面可以同时生成ios和android的，但一些涉及到底层的东西需要在ios和android单独开发，然后在js层进行调用。 学习成本高。要学习javascript系列东西，还需要涉及到ios，android开发相关知识。相比较而言，一个用过react的前端开发，写rn应该上手更快。 关于react native的开发现在并没有一些best practice，也没有真正很有经验的人，很多只能摸索。对于小团队来说，试错成本有点高，一旦卡在一些问题上，网上解决方案很少，容易耽误了整体的进度。招聘有相关经验的人也较难。 react native优势 组件化开发，复用率高，组件丰富以后，ui开发较快，前端式开发。 同时支持android和ios的ui界面。 可以方便的进行代码热更新。 Learn once,write anywhere，未来js可能会有更大的通用性，比如现在微信小程序的开发技术和react native十分相似。现在还有用react native开发mac桌面应用，开发web网页 可以和原生页面互相调用，作为一部分嵌入到一个已有的原生app中。 它是一种介于在webview和原生开发之间的解决方案，它想要实现像web一样灵活，像原生一样的性能，虽然现在还都没有达到，但是它是一种有可能接近这个目标的解决方案。 待续。。。","tags":[{"name":"react_native","slug":"react-native","permalink":"http://decodezero.cn/tags/react-native/"}]},{"title":"git实用技巧","date":"2016-08-02T00:08:08.000Z","path":"2016/08/02/git.html","text":"在工作之中使用git，除了常用的clone，add，commit，push，fetch，pull，merge等还会经常出现一些其他需要解决的问题，现在将其总结下: 忘记添加.gitignore GIT新手最容易犯的一个错误就是没有添加.gitignore，而把不该上传的东西上传了， 而GIT老手有时会因为在规则里面写了个.*而导致.gitignore没有加入到版本控制当中， 事后才发现，但此时项目中已充斥了“垃圾”。 此时项目管理者才追悔莫及，修改.gitignore并提交到版本控制当中。 但大错已铸成，新添的.gitignore不会影响已经加入到项目中的文件，GIT老手此时也可能没有什么好办法， 只能把不该有的东西手动删除掉，再重新提交。但更麻烦的是，这些“垃圾”可能还有用， 如Java项目中依赖的一些*.jar库文件，直接删了会出问题，要在修好项目后重新加回来。 如果只有几个文件还好，如果成百上千，这样操作，一天都不用干别的了。 但问题总会有聪明办法解决。GIT中用git rm --cached xxx可以在不动项目当前工作空间的情况下， 将文件从当前（未提交）版本中移除。如此而来简单方法就出来了： 123git rm -r --cached .git add .git commit -m \".gitignore is now working\" [参照这里](http://davidaq.com/technique/share/2015/04/22/gitignore-update.html) git 取消push 1234567方法1: 1. git reset -\\-hard HEAD~1 2. 然后再使用git push origin &quot;your branch name&quot; -\\-force将本次变更强行推送至服务器。这样在服务器上的最后一次错误提交也彻底消失了。方法2: 1. 在本地git revert，覆盖掉上一次的commit 2. git push origin &quot;your branch name&quot; git reflog git reflog/git log -g记录每次修改head的操作，可以查看所有历史修改记录,然后 通过git reset命令进行恢复 git merge和git rebase 如果需要merge远程分支的东西，尽量不要用git pull。 可以使用： 12git fetch origingit rebase origin/master // 可以理解为：将服务器master分支映射到本地的一个临时分支上，然后将本地分支上的变化合并到这个临时分支，然后再用这个临时分支初始化本地分支 git stash git stash 将未commit改变缓存,不保存新加的文件 git stash list 展示栈列表 git stash apply {stash@{2}} 应用某次栈中的内容 git stash pop 应用栈顶内容并弹栈 git stash clear 清空队列 git revert和git reset git revert是用一个新的提交取消掉了之前的一个错误提交 git reset取消掉最近一次commit后add的 git reset []回到那一次commit，并且将撤销掉的文件的提交恢复成未提交的状态 git reset –hard 回到那一次commit，所有过程中的文件都没了 git自动补全 参见github 单独统计每个人的增删行数 1git log --format='%aN' | sort -u | while read name; do echo -en \"$name\\t\"; git log --author=\"$name\" --pretty=tformat: --numstat | awk '&#123; add += $1; subs += $2; loc += $1 - $2 &#125; END &#123; printf \"added lines: %s, removed lines: %s, total lines: %s\\n\", add, subs, loc &#125;' -; done 打tag 1234git tag -a v1.1.2 -m 'my version' 新增taggit push origin v1.1.2 将新建的tag推到远端git tag 列出现有标签git show v1.1.2 查看相应标签的信息 错误的创建了一个文件config.java提交了以后，发现应该改为大写Config.java。但是执行git status后没有任何提示。研究后发现原因是：git 默认对于文件名大小写是不敏感的，上面修改了首字母大写,但是git并没有发现代码任何改动。解决方案是配置git config使它对大小写敏感 1git config core.ignorecase false git rebase 最低要求是没有别人正在这个分支上工作，但是即使只有自己工作在这个分枝上，如果曾经将这个分枝push到server过，本地rebase分枝B，再push到server，本地的B会和server的B发生冲突，不得不merge或者git push -f。所以最好rebase一个从没有push到server过的分枝。 rebase并不是将B的commit如C直接移动到了别的分枝上，而是创建了一个副本C1，二者的hashcode并不相同 1git rebase -i master 交互式的rebase WIP标志一些merge request可能并不希望被merge可以将其title以[WIP] 或者 WIP:开头，这样不会被merge，知道标题中移除了[WIP] 或者 WIP:","tags":[{"name":"tools","slug":"tools","permalink":"http://decodezero.cn/tags/tools/"}]},{"title":"java面试中高频的30个问题","date":"2016-08-02T00:08:08.000Z","path":"2016/08/02/30-Java-interview-questions.html","text":"在网上看到了这篇文章30个最常被问的java面试题发现这些问题和答案还挺有价值的，将其翻译总结一下。有些地方觉得英语更容易表示就直接引用了原文 为什么String不可变 安全性和效率两方面的考虑，String常量在堆中的常量池中。 抽象类可以有构造方法吗 可以，默认编译器会生成的，因为子类要调用父类的构造方法。 Object中哪两个函数被重写是为了hashtable equal和hashCode sleep，yield和wait的区别 wait是Object的函数，yield和sleep是Thread的函数。wait在同步中调用，释放所占用资源给其他线程，被notify唤醒。sleep只是将当前线程暂停一会儿，不会释放资源。yield只是释放当前线程的cpu资源，交给线程调度器来决定谁将得到cpu List和Set的区别 List有重复，Set没有重复；List有序，Set无序，但是有SortedSet，Set用equals比较，SortedSet用comparable和comparator比较；ArrayList, Vector and LinkedList实现List，HashSet和TreeSet实现Set Java怎么构建不可变的类，如String 构造函数执行之后对象的状态不再可变，任何改变都会导致产生一个新的对象；所有的域都应该是final的；对象在构造的时候一定不要把它的引用泄漏出去；class声明成final的，防止继承的类改变它。 Java用什么来表示现金或者财务的计算 用long或者BigDecimal，不要用float或者double，因为不精确。BigDecimal用字符串来初始化。 抽象类和interface用哪个 用抽象类会失去唯一的继承的机会，比如Runnable和Thread的选择；抽象类中可以有具体的方法，它更适合在演进或者不断变化的类，在抽象类中改变了，所有的子类都会影响到，接口需要改变所有的子类；Interface很适合作为一种接口来定义；抽象类是IS-A的层次 ，接口是 CAN-DO-THIS 的层次；定义一个飞的接口，鸟类可以用，飞机也可以用；List is declared as interface and extends Collection and Iterable interface and AbstractList is an abstract class which implements List. AbstractList provides skeletal implementation of List interface； HashTable和HashMap的区别 HashTable是线程安全的，HashMap不是，需要额外的同步Map m = Collections.synchronizeMap(hashMap)，所以table比较慢；Map可以插入空的key或者value；HashMap和HashTable是用Hash实现的，TreeMap是用红黑树实现的。 ArrayList和LinkedList的相同和不同相同：都是继承自List；都不是同步的；有序的；允许重复；不同：数据结构不同；Deque是用Linked实现的；增删改查不同；Linked用memory多一些 Overloading and Overriding（重载和重写） 重载时发生在编译时的，重写时发生在运行时。只有虚函数可以被重写，static，final和private的方法在java中都不能被重写 Java有几种引用类型 Strong reference, Weak references, Soft reference and Phantom reference. Except strong, all other reference allows object to be garbage collected. For example, if an object hash only weak reference, than it’s eligible for GC, if program needs space Checked vs Unchecked Exception 继承自Exception但是不继承RunTimeException的是Checked的。RunTimeException和继承自Error的是Unchecked Exception。Checked是被编译器检查的，如果块内有exception抛出，要有try，catch块。Unchecked举例：NullPointerException，ArrayIndexOutOfBound，llegalArgumentException，llegalStateException，OutOfMemmoryError。 Java的array是Object的实例吗 是，它还有length属性；他的长度是固定的 Does List can hold Integers 可以 Can we pass ArrayList\\ to a method which accepts List\\ in Java? 可以 Can we pass ArrayList\\ to a method which accepts List\\? No How to fix that? (use wildcards e.g. List&lt;? extends Number&gt; to know more about bounded and unbounded wildcards and other generics questions see this post) http://javarevisited.blogspot.sg/2012/06/10-interview-questions-on-java-generics.html volatile变量 从内存中去读，不cache；只有变量能用volatile修饰；对变量的读写是原子的； difference between CountDownLatch and CyclicBarrier in Java? javadoc里面的描述是这样的: CountDownLatch: A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes. CyclicBarrier : A synchronization aid that allows a set of threads to all wait for each other to reach a common barrier point. CountDownLatch: 一个线程(或者多个)， 等待另外N个线程完成某个事情之后才能执行。 CyclicBarrier: N个线程相互等待，任何一个线程完成之前，所有的线程都必须等待。这样应该就清楚一点了，对于CountDownLatch来说，重点是那个“一个线程”, 是它在等待， 而另外那N的线程在把“某个事情”做完之后可以继续等待，可以终止。而对于CyclicBarrier来说，重点是那N个线程，他们之间任何一个没有完成，所有的线程都必须等待。 CountDownLatch 是计数器, 线程完成一个就记一个, 就像 报数一样, 只不过是递减的.而CyclicBarrier更像一个水闸, 线程执行就想水流, 在水闸处都会堵住, 等到水满(线程到齐)了, 才开始泄流. CountDownLatch是一次性的，而CyclicBarrier在调用reset之后还可以继续使用 BlockingQueue是线程安全的吗 是 Why wait and notify method should be called in loop? To prevent doing task, if condition is not true and thread is awake due to false alarms, checking conditions in loop ensures that processing is only done when business logic allows What is difference between “abc”.equals(unknown string) and unknown.equals(“abc”) 前者不会出现NullPointerException What is marker or tag interface in Java? an interface, which presence means an instruction for JVM or compiler e.g. Serializable, from Java 5 onwards Annotation is better suited for this job, to learn more and answer in detail see this discussion. http://javarevisited.blogspot.sg/2012/01/what-is-marker-interfaces-in-java-and.html Difference between Serializable and Externalizable interface in Java? later provides more control over serialization process, and allow you to define custom binary format for your object, later is also suited for performance sensitive application Can Enum types implement interface in Java? Yes Can enum extend class in Java? 不可以，因为java规定一个class只能继承一个class。enum默认继承自java.lang.Enum How to prevent your class from being subclassed? Make it final or make constructor private 静态方法可以重写吗 不会出现编译错误，但是不会有重写的效果，因为静态方法是编译时绑定的 Which design pattern have you used recently? give any example except Singleton and MVC e.g. Decorator, Strategy or Factory pattern StringBuffer和StringBuilder的区别 StringBuffer is synchronized while StringBuilder is not which makes StringBuilder faster than StringBuffer.Use String if you require immutability, use Stringbuffer in java if you need mutable + thread-safety and use StringBuilder in Java if you require mutable + without thread-safety.","tags":[{"name":"java","slug":"java","permalink":"http://decodezero.cn/tags/java/"}]},{"title":"Java内存虚拟机总结","date":"2016-07-21T00:08:08.000Z","path":"2016/07/21/Java-memory.html","text":"读过几遍周志明老师的《深入理解Java虚拟机:JVM高级特性与最佳实践》获益匪浅，但是关于一些问题经常忘记又需要重新翻阅。现在将其中内存虚拟机相关章节的内从自己浓缩总结一下，以供参阅。 1. Java内存区域介绍 程序计数器：每个线程独有，如果线程正在执行一个Java方法，这个计数器记录的是正在执行的虚拟机字节码地址，如在执行native方法，则计数器的值为空。唯一没有规定任何OutOfMemoryError的区域 虚拟机栈：每个线程独有的，每个方法被执行的时候都会同时创建一个栈帧用于存储局部表量表，操作栈，动态链接，方法出口等。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。局部变量表存放了编译器可知的基本数据类型如int等和对象引用和returnAddress类型（指向一条字节码指令的地址）。局部变量表所需要的内存空间在编译期间完成分配。存在两种异常。StackOverflowError：线程请求的栈深度大于虚拟机所允许的深度。 本地方法栈：和虚拟机栈类似。虚拟机栈执行java方法，本地方法栈执行Native方法。有些虚拟机会如Sun HotSpot会把二者合二为一。 Java堆：被所有线程共享，在虚拟机启动时创建，此内存区域的唯一目的就是存放对象实例。Java堆可以出于物理上不连续的内存空间。会抛出OutOfMemoryError异常 方法区：被所有线程共享，存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码。垃圾回收很少出现，主要针对常量池的回收和类型的卸载。运行时常量池是方法取得一部分，Class文件除了有版本、字段、方法等信息，还有常量表用于存放编译期生成的各种字面量和符号引用。类加载后这部分内容放到运行时常量池中。 2. 对象访问两种方式 句柄：Java堆中会划分出一个句柄池，reference中存储的是对象的句柄地址，句柄中包含真实地址。对象被移动时只需要改变句柄中实例数据指针，reference不需要修改。 直接指针：速度更快。 3. 垃圾回收问题1：寻找一个对象是否存活的方法 引用计数法：无法解决对象相互循环引用的问题。 跟搜索算法：能否到GC Roots。如果能则存活，不能则应该回收 问题2：回收算法 标记清除算法：首先标记处所有需要回收的对象，在标记完成后统一回收掉被标记的对象。存在效率低和空间内存碎片的问题。 复制算法：现在商用虚拟机用来回收新生代。将内存分为较大Eden和两块较小Survivor，每次使用Eden和一块Survivor。回收时，Eden和Survivor中还存活着的一次性拷贝到另外一块Survivor，同时清理Eden和用过的Survivor。默认8:1:1。 标记-整理算法：适用于老年代，让所有的存活的对象都向一段移动，然后直接清理掉边界以外的内存。现在整体采用的是分代收集算法。大对象直接进入老年代，长期存活的对象进入老年代","tags":[{"name":"java","slug":"java","permalink":"http://decodezero.cn/tags/java/"}]}]